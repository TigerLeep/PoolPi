var log4js = require("log4js")
var request = require("request");
var dblite = require("dblite");
var async = require("async");

var store = function()
{
    var _log = log4js.getLogger("poolpi");
    var _privateKey = "Fill In Private Key Here";
    var _publicKey = "ZGgvMoJLR8Hjo7JjWzao";
    var _url = "http://data.sparkfun.com/input/" + _publicKey;

    var _databaseFile = "./data/poolpi.db";

    createDatabaseIfNeeded();
    
    this.Save = function(poolData)
    {
        // Attempt to save any data in the local cache to the online store.
        // This would be data that previously failed to save to the online store.
        trySaveCacheToStore();

        // Put together the new data to save.
        var data =
            "reading_time=" + poolData.ReadingTime.toISOString()
            + "&air_temperature=" + poolData.AirTemperature.toString()
            + "&pool_temperature=" + poolData.PoolTemperature.toString();
        _log.info("Entry: " + data);
        _log.info("Attempting to save new entry.");

        // Attempt to save the new data to the online data store
        saveToStore(data, function(error, response, body)
        {
            if (error || body != "1 success\n")
            {
                // Something went wrong saving to the online store.
                // Log the error and save to local cache for now.
                _log.error("An error occurred saving new entry to the store.");
                if (error)
                {
                    _log.error(error);
                }
                if (body)
                {
                    _log.error("Body = " + (body || ""));
                }
                saveToCache(data);
            }
            else
            {
                _log.info("New entry saved to store.");
            }
        });
    };

    function trySaveCacheToStore()
    {
        var db = dblite(_databaseFile).on("close", function(code) { });
        
        // Pull a list of data in the cache waiting to be saved to the online store.
        db.query(
            "SELECT * FROM poolpi",
            {id: Number, data: String},
            function(err, elements)
            {
                if (err)
                {
                    // Something went wrong querying the cache.
                    _log.error("An error occurred reading the cache.");
                    _log.error(err);
                    db.close();
                }
                else
                {
                    if (elements.length == 0)
                    {
                        // The cache is empty.  This is good; it means there have been
                        // no errors trying to save to the online store.
                        _log.info("No entries in cache to save.");
                        db.close();
                        return;
                    }
                    var idsToDelete = [];
                    var parallelCalls =
                    [
                    ];

                    _log.info("Attempting to save " + elements.length + " entries from cache.");

                    // Save up to the first 50 items in the cache.  We don't want too many at once
                    // (thus the 50 max limit) or we risk the online data store blocking our calls.
                    // data.sparkfun.com has a 100 call limit within 15 minutes, so limiting to
                    // 50 here is a good safe margin.  If there are more than 50 in the cache then
                    // the rest will be picked up next time.
                    for(var index = 0; index < Math.min(elements.length, 50); index++)
                    {
                        var id = elements[index].id;
                        // Put together an array of functions to call in parallel to save the
                        // items in the cache (one for each item in the cache to attempt to save).
                        // Each entry in the array is generated by an anonymous method that is
                        // passed the element from the cache to save in order to form a closure
                        // around it so the callback function passed to saveToStore gets the
                        // correct element.
                        parallelCalls.push((function(element)
                        {
                            return function(callback)
                            {
                                
                                saveToStore(element.data, function(error, response, body)
                                {
                                    if(!error && body == "1 success\n")
                                    {
                                        _log.info("Saved entry from cache.");
                                        callback(null, {id: element.id});
                                    }
                                    else
                                    {
                                        _log.error("An error occurred saving entry from cache to the store.");
                                        if(error)
                                        {
                                            _log.error(error);
                                        }
                                        if (body)
                                        {
                                            _log.error("Body = " + (body || ""));
                                        }
                                        callback("Entry from cache failed to save.", null);
                                    }
                                });
                            };
                        })(elements[index]));
                    }
                    
                    // Call all the saveToStore functions we just put in an array in parallel.
                    async.parallel(
                        parallelCalls,
                        function(err, result)
                        {
                            // All the async calls to saveToStore have finished.
                            if (err)
                            {
                                // Something went wrong.
                                _log.error("An error occurred attempting to save entries from cache.");
                                _log.error(err);
                            }
                            else
                            {
                                // All the saveToStore calls succeeded.  result contains ids of the
                                // cache elements successfully saved.  We need to delete them.
                                for(var index = 0; index < result.length; index++)                                
                                {
                                    db.query("DELETE FROM poolpi WHERE ID = ?", [result[index].id]);
                                }
                                _log.info("Deleted " + result.length + " entries from cache.");
                            }
                            db.close();
                        });
                }
            });
    }
    
    function saveToStore(data, onSave)
    {
        request(_url + "?private_key=" + _privateKey + "&" + data, function(error, response, body)
        {
            if (onSave != null && typeof(onSave) == "function")
            {
                onSave(error, response, body);
            }
        });
    }

    function saveToCache(data)
    {
        var db = dblite(_databaseFile).on("close", function(code) { });
        _log.info("Saving entry to cache.");
        db.query("INSERT INTO poolpi (data) VALUES (?)", [data]);
        db.close();
    }
    
    function createDatabaseIfNeeded()
    {
        var db = dblite(_databaseFile).on("close", function(code) { });
        db.query("CREATE TABLE IF NOT EXISTS poolpi (id INTEGER PRIMARY KEY, data TEXT)");
        db.close();
    }
};

module.exports = store;
